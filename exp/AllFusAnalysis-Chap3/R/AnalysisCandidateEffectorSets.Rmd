---
title: "Analysis of Candidate Effectors"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data set

Candidate effectors were generated as part of the Third Chapter of my thesis. They were identified using the [Maei pipeline](https://github.com/JamiePike/Maei) in a set of *Fusarium* genomes. For the full set of genomes and the previous command line scripts and analysis, see [Process.md](https://github.com/JamiePike/Maei/docs/Process.md). 

```{r libraries, echo=FALSE, include=FALSE}
# # ---- Install required packages ---- #
# install.packages("ggtree")
# if (!requireNamespace("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install("ggtree")
# install.packages('devtools')
# devtools::install_github("YuLab-SMU/ggtreeExtra")
# install.packages('tidytree')
# install.packages('ggpubr')
# install.packages('nortest')
# library(devtools)
# install_github("jokergoo/ComplexHeatmap")

# ---- Load required libraries ---- #
#for stats
library(dplyr)
library(tidyr)
library(tidytree)
library(tidyverse)
library(dplyr)
library(forcats)
library(ggplot2)
library(ggthemes)
library(viridis)
library(ggpubr)
library(nortest)

# for phylogeny
library(phytools)
library(ggtree)
library(ggtreeExtra)
library(ape)

#for heatmaps
library(ComplexHeatmap)
library(textshape)
library(RColorBrewer)
library(ggnewscale)
library(pheatmap)
library(circlize)
```


```{r load data}

# ---- Set dirs and load files ---- #
setwd("/Volumes/Jamie_EXT/Projects/Maei/exp/AllFusAnalysis-Chap3/R/")
# Specify  path to  Newick file
tree_file <- "./MaeiTEFPhylo.treefile"
# Load heatmap data matrix from the CSV file
data <- read.csv("./PhyloHeatmapData.csv")  # Adjust the path accordingly
# Load phylogeny meta date from the CSV file
metadata <- read.csv("./PhyloMetaData.csv") 

```

After loading my data, I prepared it for subsequent analysis. The metadata and heatmap data are currently in .csv format, but that saves empty cells as "", and I want them to be `NA` values (particularly the metadata). I also added columns which contains the "full name" for each genome assembly, where full name is the genus (abbreviated), species, and forma speciales (fsp). 

```{r prepare metadata}
# ---- prepare metadata ---- #
# ensure its a df
metadata <- as.data.frame(metadata)
# clear empty values
metadata$fsp[metadata$fsp==""] <- NA # set empty cells in fsp column to NA
metadata$race[metadata$race==""] <- NA # set empty cells in race column to NA

#create a column for full fsp.
metadata <- metadata %>% unite("full_name", c(species,fsp), sep = " fsp. ", remove = F, na.rm = T)

# build df for fsp so we can add it as a colour scale to the tree
fsp_df <- data.frame("fsp" = metadata[,c("fsp")] )
rownames(fsp_df) <- metadata$label

```

## Tef-1a tree of isolates

Now I have my database of isolates, I need to know how they are related. I have already performed the phylogenetic analysis, here I am plotting the results. First, I rooted the tree through F._graminearum_PH-1 *Tef1-a*, and built the basic tree skeleton. I also loaded in the metadata for labeling later. Additionally, I built a basic tree with the nodes labeled, so that I can use that for later reference 

```{r prep tree, fig.width= 20}
# ---- Prepare the tree ---- #
# Read the phylogenetic tree from the Newick file
unrootedtree <- read.tree(tree_file)
# root the tree
tree <- root(unrootedtree, outgroup = c("F._graminearum_PH-1"))
# Build tree skeleton
p <- ggtree(tree,ladderize = F)  %<+% metadata

# ---- View the tree ---- #
# Useful for visualusing nodes etc 
p_nodes <- p + 
  geom_text2(aes(label = parent), hjust = -0.1, size = 3)+ # add node names
  geom_tiplab(aes(label = label), offset = 0.005) +
  coord_cartesian(clip = "off") # stop names being trimmed off
```

Now I have my basic tree, I can start to build something that will stand alone. First I added the metadata (full name, the isolate code, and race).

```{r TEF1a tree, results= 'hide'}
# ---- Build the tree plot ---- #

p2 <- p +  
  geom_treescale(x = 0, y = 1, width = 0.004) + 
  geom_tiplab(aes(label = full_name)) +
  geom_tiplab(aes(label = isolate_code), color = "grey20", offset = 0.015, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = race), color = "grey20", offset = 0.024, linetype = "blank", geom = "text", align = TRUE)+
  geom_tippoint(aes(shape = source)) +
  geom_rootedge() +
  theme(legend.position = "bottom")

#add extra scale so we can plot fsp with colour
p3 <- p2 + new_scale_fill()
# add race data
p4 <- gheatmap(p3, fsp_df,
               offset = 0.008, 
               width = 0.03,
               color = "grey20",
               colnames = FALSE) +
  scale_fill_manual(name = "Fsp",
                    values = c("blue","purple","goldenrod4","grey90","gold","brown", "lightpink","darkolivegreen3", "grey20", "tomato", "lavender", "tan", "palegreen4", "coral", "yellow"), na.value = "grey") +
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "vertical", legend.margin = margin())+
  guides(shape = guide_legend(override.aes = list(size = 2)))
```

The TR4 isolates group into a monophyletic clade, as expected; as do the *lactucae* isolates. The TNAU isolates group as they did in the previous TEF1a and RBP2 phylogenies (chapter 2). Isolates of the same fsp and race do not all group in the same clade (e.g. *Fo.* fsp. *cubense* Race 1)

```{r TEF1a tree plot, fig.height= 10, fig.width= 30, fig.cap="TEF phylogeny of Fusarium isolates included int effector anaylisis.The tree is rooted through F. graminearum."}
# plot it 
plot(p4)

##save basic tree 
ggsave("BasicTEFPhylo.png", width = 30, height = 15)
```

## Analysis of candidate effectors, *mimps* and genome size in data set

Once the candidate effectors had been identified in the candidates, I conducted some basic statistics to see how they were distributed.

First, I subset the data I needed from the `Metadata`, and removed the isolates that were included in the TEF1a phylogenies but not the Maei analysis. 

```{r stats data set}
# ----  tidy the data for stats ----#
#subset the df so that we can perform stats on genome size and mimp/cand eff distribution
stats_data <- select(metadata, "species", "fsp", "isolate_code","no._mimps","no._cand_effs","genome_size") %>%
#Rename the columns to reduce the long titles
   dplyr::rename(isolate=isolate_code,
         mimps=no._mimps,
         candidate_effectors=no._cand_effs,
         assembly_size =genome_size)

#we need to drop rows which were not included in the Maei analysis
stats_data <- stats_data %>%
  drop_na(candidate_effectors)

# view the table for stats data
knitr::kable(stats_data)
```

The number of *mimps*,  candidate effectors identified, and genome sizes varies between genome assemblies. 

```{r stats_data}
# ---- sumarise the data ---- #
summary(stats_data$mimps)
summary(stats_data$candidate_effectors)
summary(stats_data$assembly_size)
```

I also want to look at specific fsp. to determine if the avernage number of effectors, *mimps*, and genome size is smaller compared to other fsp. To do this, I `subset` the fsp. I am interested in and then use the `summary` function in R. 

```{r subset stats for fsp}
# ---- subset the fsp of interest ---- #
# cubense
foc_stats <- subset(metadata, grepl("Fo._fsp._cubense", label))
summary(foc_stats)
# lactucae
fola_stats <- subset(metadata, grepl("Fo._fsp._lactucae", label))
summary(fola_stats)
# apii 
foa_stats <- subset(metadata, grepl("Fo._fsp._apii", label))
summary(foa_stats)
# coriandrii
foci_stats <- subset(metadata, grepl("Fo._fsp._coriandrii", label)) 
foci_stats <- foci_stats %>%
  drop_na(no._mimps)
summary(foci_stats)
```

### Correlation and distribution

I want to see if there is a relationship between the assembly size, *mimp* content, and candidate effector number, so calculated correlation. 

First, I checked the distribution of the data, to determine the best correlation test to perform. 

```{r distribution plots}
# ---- Build the histograms ---- #
# visualise the mimp distribution
mimps_histo <- ggplot(stats_data, aes(x = mimps)) +
  geom_histogram(fill = "#0c4c8a", colour = "grey20" ) +
  theme_bw()

# visualise the mimp distribution
cands_histo <- ggplot(stats_data, aes(x = candidate_effectors)) +
  geom_histogram(fill = "#0c4c8a", colour = "grey20" ) +
  theme_bw()

# visualise the mimp distribution
size_histo <- ggplot(stats_data, aes(x = assembly_size)) +
  geom_histogram(fill = "#0c4c8a", colour = "grey20" ) +
  theme_bw()

```

The data are not normality distributed. The Pearson correlation is computed by default with the `cor.test()` function.

I also visualized the data using scatter plots to check that the data are linearly related. 

```{r correlation plots}

# ---- Build the scatter plots ---- #
#Correlation between the total number of effectors and  the total number of mimps
#Visualize the relationship
effectors_v_mimps_relat <- ggplot(stats_data) +
  aes(x = candidate_effectors, y = mimps) +
  geom_point(colour = "#0c4c8a") +
  geom_smooth(method = "lm", se = FALSE, color = "grey20") +
  theme_bw()

#Correlation between  the total number of effectors and Assembly Size?
#Visualize the relationship
effectors_v_assembly_size_relat <- ggplot(stats_data) +
  aes(x = candidate_effectors, y = assembly_size) +
  geom_point(colour = "#0c4c8a") +
  geom_smooth(method = "lm", se = FALSE, color = "grey20") +
  theme_bw()

#Correlation between the total number of mimps and Assembly Size?
#Visualize the relationship
mimps_v_assembly_size_relat <- ggplot(stats_data) +
  aes(x = mimps, y = assembly_size) +
  geom_point(colour = "#0c4c8a") +
  geom_smooth(method = "lm", se = FALSE, color = "grey20") +
  theme_bw()

```


```{r stats plots, fig.height= 15, fig.width= 35, fig.cap= "Plots of meta data, showing distribution and relationship of assembly size, mimp, and candidate effector content"}

# combine the plots 
sats_plots <- ggarrange(mimps_histo, cands_histo, size_histo, mimps_v_assembly_size_relat, effectors_v_assembly_size_relat, effectors_v_mimps_relat,
          ncol = 3, 
          nrow = 2)

# plot the combined plots
plot(sats_plots)


#save it 
ggsave("./SummaryStats.png", width = 20, height = 15)

```

There is a general positive trend in the data between candidate effector number and total number of mimps identified. 

Note: the correlation between variables X and Y is equal to the correlation between variables Y and X so the order of the variables in the `cor.test()` function does not matter. 


```{r candidate effectors and mimps correlation"}
#Correlation test:
effectors_v_mimps <- cor.test(stats_data$candidate_effectors, stats_data$mimps, )
effectors_v_mimps
```
For the correlation between "candidate_effectors" and "mimps," the Pearson's correlation coefficient is 0.88. This indicates a strong positive correlation between these two variables. The p-value (1.674e-14) is very small, suggesting that this correlation is statistically significant. The 95 percent confidence interval for the correlation coefficient ranges from 0.786 to 0.934. Overall, it implies a robust and positive association between "candidate_effectors" and "mimps" in my data.

```{r candidate effectors and assembly size}

#Correlation test:
effectors_v_assembly_size <- cor.test(stats_data$candidate_effectors, stats_data$assembly_size) 
effectors_v_assembly_size
```
Similarly, for the correlation between "candidate_effectors" and "assembly_size," the Pearson's correlation coefficient is 0.91. This indicates a very strong positive correlation between these two variables. The p-value is extremely small (< 2.2e-16), indicating that this correlation is highly statistically significant. The 95 percent confidence interval for the correlation coefficient ranges from 0.837 to 0.951. Overall, it suggests a strong and positive association between "candidate_effectors" and "assembly_size" in my dataset.

```{r mimps and assembly Size}

#Correlation test:
mimps_v_assembly_size <- cor.test(stats_data$mimps, stats_data$assembly_size)
mimps_v_assembly_size
```

The Pearson's correlation coefficient between "mimps" and "assembly_size" variables is 0.87. This indicates a strong positive correlation between the two variables. The p-value is very small (7.091e-14), suggesting that this correlation is statistically significant. The 95 percent confidence interval for the correlation coefficient ranges from 0.770 to 0.929. Overall, it implies a robust and positive association between the variables in my data.

### Relationship between predicted effectors, *Mimps* and Assembly size

Although I have ploted and calculated correlation between the number of *mimps*, candidate, effectors and assembly size, it is not easy to visualise/see in one place. Therefore, I generated a single plot which contains the number of *mimps*, candidate effectors, and assembly size for each isolate. This makes it quick and easy to visualise, and see if there is a relationship between the variables. 

First, I have to prepare my data set. I used the metadata file loaded initially. 
```{r stats final plot data }
# ---- Prepare Data for plotting --- #
#Extract the isolate, assembly size, total number of mimps and effectors columns.
stats_plot_data <- select(metadata,"species", "species_group", "fsp", "isolate_code","genome_size","no._mimps","no._cand_effs") %>%
#Rename the columns to reduce the long titles
  dplyr::rename(isolate=isolate_code,                                    
         mimps=no._mimps,
         candidate_effectors=no._cand_effs,
         assembly_size =genome_size) %>%  
#We need to drop rows which were not included in the Maei analysis
  drop_na(candidate_effectors) %>%
#Merge/group the fsp and isolate code columns so that both can be plotted.
   unite(ID, c(fsp, isolate), sep = " ", remove = T, na.rm = T) %>%
#Merge/group the mimps and effector columns so that both can be plotted per strain/isolate.
  pivot_longer(cols = c(mimps,candidate_effectors), names_to="Legend", values_to="mimps_and_candidate_effectors") %>%  
  mutate(Legend = factor(Legend, levels=c('mimps','candidate_effectors')))

```

Once the data was prepared, I produced a plot using ggplot2. 

```{r stats final plot, fig.width= 15, fig.height= 10, fig.cap="Figure 4:Relationship between candidate effectors, *mimps* and assembly size."}
#Build plot
#----------

#Generate scale for Assembly size data 
scale_right <- 100 / max(stats_plot_data$mimps_and_candidate_effectors)

#Build Plot
stats_plot <- ggplot(aes(x=reorder(ID, mimps_and_candidate_effectors)),   #Create X axis, which contains all strains/isolates assessed ordered by the total number of mimps and effectors 
               data = stats_plot_data)+  
  geom_bar(aes(y=mimps_and_candidate_effectors,                  #Plot the total number of mimps and effectors 
               fill = Legend),
           colour="grey20",
           position= 'dodge',                          #Ensure the bars are not stacked. 
           stat='identity')+                           #Add the mimp or predicted effector content. 
  scale_fill_manual("Legend", values=c("candidate_effectors" = "darkolivegreen", "mimps" = "#DDE0DA"), label=c("mimps", "candidate effectors"))+ #for some reason the labels have to be written the other way round...?
  facet_grid(~species_group,
             scales = "free_x",                        # Let the x axis vary across facets.
             space = "free_x",                         # Let the width of facets vary and force all bars to have the same width.
             switch = "x")+                            # Move the facet labels to the bottom.
  geom_point(aes(y=assembly_size /scale_right,         #Plot assemble size over the top of the bar chart.
                 colour = "Assembly Size",             #Add assembly size to the legend. 
                 group = 1), 
             size = 3)+ 
  scale_colour_manual(" ", values=c("Assembly Size" = "grey50"))+
  theme_bw()+
  theme(legend.box="verticle",
        legend.title = element_blank(),
        legend.position = "bottom")+
  xlab("") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank())+
  theme(axis.text.x = element_text(angle = 90,         #Adjust the text orientation on the x axis
                                   vjust = 0.5, 
                                   hjust=1,
                                   size = 12))+
  theme(axis.text = element_text(size = 12))+
  scale_y_continuous(name= "Total number of mimps \nand candidate effectors", #Increase ticks on Y axis.
                     breaks = scales::pretty_breaks(n = 10),                     #Create regular breaks in the Y axis. 
                     sec.axis = sec_axis( trans=~.*scale_right,                   #Insert second Y axis for the assembly size. Calculated using the right-hand scale.   
                                          name="Size of Assembly (Mb)", 
                                          breaks = scales::pretty_breaks(n = 15)
                     ))
# print the plot
plot(stats_plot)
#Prepare png of file 
ggsave("StatsOverview.png", width = 10, height = 10)

```
### Additional statsistics 

I considered performing t-tests to see if there was a significant difference in the number of *mimps* and candidate effectors identified between race in each fsp, but as the number of fsp for *Fo.* fsp. *cubense* was not even, and one of the three Race 1 isolates reported might not be pathogenic (Foc1 60), I decided not to test for significance - even using non-parametric tests. The sample number is too low. 

I wondered if there was a reduced number of effectors in the Foc isolates compared to the other fsp. They do consistently seem to have fewer identified. Further, I wondered if there was a difference in the number of *mimps* and candidate effectors between different races of the same fsp, even if it was not signifcant. 

I plotted the mimp and effector content from the metadata and visualised it using `ggplot.`

```{r effector and mimp race plots, fig.width= 12}

# ---- Prepare Data for plotting --- #
#Extract the isolate, assembly size, total number of mimps and effectors coloumns.
race_plot_data <- select(metadata,"species", "species_group", "fsp", "race" ,"isolate_code","genome_size","no._mimps","no._cand_effs") %>%
#Rename the columns to reduce the long titles
  dplyr::rename(isolate=isolate_code,                                    
         mimps=no._mimps,
         candidate_effectors=no._cand_effs,
         assembly_size =genome_size) %>%  
#We need to drop rows which were not included in the Maei analysis
  drop_na(candidate_effectors) %>%
#Merge/group the mimps and effector columns so that both can be plotted per strain/isolate.
  pivot_longer(cols = c(mimps,candidate_effectors), names_to="Legend", values_to="mimps_and_candidate_effectors") %>%  
  mutate(Legend = factor(Legend, levels=c('mimps','candidate_effectors')))


# ---- subset metadata ---- #
# extract only the fsp we are interested in and drop isolates which don't have a race classification
race_plot_data_subset <- subset(race_plot_data, grepl("lactucae|apii|cubense", fsp)) %>%
  drop_na(race)

# ---- funky cheats to lable the facet plot nicely --- #

#set new labels
new_labels_y <- c("mimps" = "mimps", "candidate_effectors" = "candidate effectors")
new_labels_x <- c("apii" = "Fo. fsp. apii", "cubense" = "Fo. fsp. cubense", "lactucae" = "Fo. fsp. lactucae")


# ---- build plots ---- #
theme_set(theme_pubr()) #set the ggpubr theme

# build plots for candidate effectors and mimps 
mimpsandcandeffs <- ggplot(race_plot_data_subset, aes(x=race, y=mimps_and_candidate_effectors)) + # plot race and mimp/candidate effector count
  geom_boxplot(aes(fill = Legend)) +
  facet_wrap(~ fsp, labeller = labeller(Legend = new_labels_y, fsp = new_labels_x), scales = "free_x") +  # split the plot by fsp and then mimps/candidate effectors
  labs(x = "Race", 
       y = "Total number of mimps \nand candidate effectors") +
  scale_fill_manual(values = c("candidate_effectors" = "darkolivegreen", "mimps" = "#DDE0DA"), label=c("mimps", "candidate effectors")) +
  theme_bw() +
  theme(strip.text.y = element_blank(),  # remove the side names as we have this shown in colour now. 
        panel.grid.major = element_blank(), # put the lines back in 
        legend.position = "bottom", 
        legend.title = element_blank()) 

#plot it 
plot(mimpsandcandeffs)

#save the plot
ggsave("MimpsAndCandEffs_FspOfInterest.png", width = 10, height = 10)


```

I want to put some values to this to dicuss in the text of my thesis.

```{r race stats in fsp}
# ---- subset the fsp of interest ---- #
# cubense
foc_stats_sum <- foc_stats %>%
  group_by(race) %>%
  summarize(count = n_distinct(label),
            mean_mimp = mean(no._mimps),
            min_mimp = min(no._mimps),
            max_mimp= max(no._mimps),
            mean_eff = mean(no._cand_effs),
            min_eff = min(no._cand_effs),
            max_eff = max(no._cand_effs),
            sum_eff = sum(no._cand_effs))
# lactucae
fola_stats_sum <- fola_stats %>%
  group_by(race) %>%
  summarize(count = n_distinct(label),
            mean_mimp = mean(no._mimps),
            min_mimp = min(no._mimps),
            max_mimp= max(no._mimps),
            mean_eff = mean(no._cand_effs),
            min_eff = min(no._cand_effs),
            max_eff = max(no._cand_effs),
            sum_eff = sum(no._cand_effs))
# apii 
foa_stats_sum <- foa_stats  %>%
  group_by(race) %>%
  summarize(count = n_distinct(label),
            mean_mimp = mean(no._mimps),
            min_mimp = min(no._mimps),
            max_mimp= max(no._mimps),
            mean_eff = mean(no._cand_effs),
            min_eff = min(no._cand_effs),
            max_eff = max(no._cand_effs),
            sum_eff = sum(no._cand_effs))

# print it nicely
knitr::kable(foc_stats_sum)
knitr::kable(fola_stats_sum)
knitr::kable(foa_stats_sum)

```

## Candidate effector distribution

Now I have an understanding of the effector distribution and the phylogeny, I combined the phylogenies and effector profiles to generate a binary presence/absence heatmap. 

### Summary statistics of candidate effector clusters

As we are looking at clustered (0.65% ID, cd-hit (v...)) and filtered sequences (SignalP (v5.06) and EffectorP (v2.0.1) extracted from BLAST hits, the total number of candidate effectors per cluster per isolate varies, but I want to just look at Presence/Absence. In order to do this, I converted the heatmap data matrix to a binary data frame. However, I don't just want to work with the binary data, so I'll make a second df I can use later.

```{r heatmap data prep}

# ---- prep the binary heatmap data ---- #
# remove the row names temporarily 
rownames_mat<- data[,1]
mat_data<- as.matrix(data[,-1])
#make data frame binary 
binary_matrix <- as.matrix(mat_data)
binary_matrix[binary_matrix > 0] <- 1
#put rownames back
rownames(binary_matrix)<-rownames_mat

# ---- prep the heatmap data ---- #
# make the CEC data a matric
CEC_matrix<- as.matrix(data)
# make it a df 
CEC_df <- as.data.frame(CEC_matrix)

metadata

```


First, I wanted to look at the distribution of the these clusters in numerical terms. How many are shared among all assemblies? How many are shared among all Fo. assemblies? How many core CECs are there in cubense? etc. 

```{r summary stats of effector clusters}

# ---- summarise the distribution of candidate effector clusters ---- #
# convert the matrix to a data frame
CEC_binary_df <- as.data.frame(binary_matrix)

# count the number of columns (minus the label column) to get the total number of CECs
total_CECs <- ncol(CEC_binary_df)

# total number of candidate effector clusters per assembly (as a dataframe)
cluster_distib <- enframe(colSums(t(CEC_binary_df[-1])))
#rename the value column 
cluster_distib <- dplyr::rename(cluster_distib, no._CECs = value)
# merge the two data frames
metadata <- merge(metadata, cluster_distib, by.x = "label", by.y = "name", all.x = TRUE)

#subset the metadata ft 
CEC_metadata <- select(metadata,"species", "species_group", "fsp", "race", "isolate_code","genome_size","no._mimps","no._cand_effs", "no._CECs")

# print it nicely
knitr::kable(CEC_metadata)

# # summarise it for chapter text
# summary(CEC_metadata)

```

Now I want to look at the size of the CECs, how many sequences are there in each? Do any fsp have unique CECs which are expanded?

```{r CEC sizes and distribution by fsp}

# ---- Prep the heatmap data ---- #
# join the metadata in to make filtering and manipulation later easier
 CEC_df_all <- left_join(metadata, CEC_df, by = c("label" = "Isolate"))

# ---- group by fsp ---- #

# calculate the total number of CEs in a given CEC per fsp.
CEC_sizes <- CEC_df_all %>% 
  group_by(full_name) %>%
  mutate(across(starts_with("Cluster"),
              ~ as.numeric(as.character(.)))) %>% 
  summarize(across(starts_with("Cluster"), sum, na.rm = TRUE))

# use the CEC_sizes output to find the range for each fsp (highest number of CEs in a CEC and lowest number of CEs in a CEC, not counting 0)
CEC_ranges <- CEC_sizes %>%
  pivot_longer(cols = starts_with("Cluster"), names_to = "column") %>%
  filter(value != 0) %>%
  group_by(full_name) %>%
  summarise(num_highest = sum(value == max(value)), #  report the number of clusters with the max value, just incase it is more than one.
            highest = if_else(num_highest == 1, first(column[which.max(value)]), NA_character_), #  report the highest cluster unless it is > 1. 
            highest_value = max(value),
            num_lowest = sum(value == min(value)), #  report the number of clusters with the min value, becuase it is likely to be more than one.
            lowest = if_else(num_lowest == 1, first(column[which.min(value)]), NA_character_), #  report the lowest cluster unless it is > 1. 
            lowest_value = min(value))

# print it nicely
knitr::kable(CEC_ranges)

```

Now i want to see what clusters are largest and smallest overall.

```{r CEC sizes and distribution}

# now calculate the largest clusters
CEC_overall_sizes <- CEC_sizes %>%
  pivot_longer(cols = -full_name, names_to = "column") %>%
  filter(value != 0) %>%
  group_by(column) %>%
  summarise(total_value = sum(value),
            num_values = sum(value != 0)) %>%
  ungroup() %>%
  summarise(largest_column = column[which.max(total_value)],
            largest_total = max(total_value),
            num_largest = sum(total_value == max(total_value)),
            smallest_total = min(total_value),
            num_smallest = sum(total_value == min(total_value)))
            
# print it nicely
knitr::kable(CEC_overall_sizes)

```


I clustered the data in the binary data matrix, so that it will be ordered  when I visualise the candidate effector heatmap.

```{r dendrogram of effector clusters, fig.height= 5, fig.width= 20}
# ---- Cluster the heatmap data ---- #
# normalisiation is mandatory for clustering, but as my data is binary - i did not normalise. 
# Compute hierarchical clustering of columns
heatmap_dat <- cluster_matrix(binary_matrix, method ="ward.D2")

```


### Build heatmap of CECs

Next, I build the CEC heatmap. I did originally do this alongside the TEF phlyo, but it looks messy and unclear, plus you can see the fsp clusters more clearly using ComplexHeatmap::pheatmap. 

```{r final heatmap, fig.height= 12, fig.width= 24}
# ---- Add metadata to heatmap ---- #

# first, select the data we want from metadata and make the "label column in metadata the row names"
heatmap_metadf <- select(metadata,"label","no._mimps","no._cand_effs", "no._CECs", "race", "full_name", "isolate_code") %>%
  dplyr::rename(name=label,
                Species =full_name,
                CECs=no._CECs,
                CEs = no._cand_effs,
                mimps =no._mimps,) %>% 
  drop_na(CECs) %>%
  mutate(across('Species', str_replace, 'F. oxysporum', 'Fo.')) %>% # shorten the species name for Fusarium oxysporum.
  unite(ID, c(Species, isolate_code), sep = " ", remove = F, na.rm = T) %>%
  remove_rownames %>% 
  tibble::column_to_rownames(var="name")
# because complex heatmap cant cope with the order of the df being different from the matrix, I have to reorder out df to match the matrix.
heatmap_metadf_ordered<- heatmap_metadf[rownames(binary_matrix), ]

#add isolate ids
ID <- as.list(heatmap_metadf_ordered$ID)

# ---- set my colours ---- #

anno_colours_r <- list(
           Species = c(
             "Fo. fsp. apii" = "blue",
             "Fo. fsp. cepae" = "purple",
             "Fo. fsp. conglutinans" = "goldenrod",
             "Fo. fsp. coriandrii" = "grey90",
             "Fo. fsp. cubense" = "gold",
             "Fo. fsp. lactucae" = "darkolivegreen3",
             "Fo. fsp. lini" = "indianred",
             "Fo. fsp. lycopersici" = "tomato",
             "Fo. fsp. matthiolae" = "lavender",
             "Fo. fsp. narcissus" = "yellow",
             "Fo. fsp. niveum" = "palegreen4",
             "Fo. fsp. rapae" = "slateblue",
             "Fo. fsp. from rocket" = "tan",
             "Fo. fsp. vasinfectum" = "steelblue",
             "Fo. fsp. endophyte" = "brown",
             "F. graminearum" = "burlywood4",
             "F. sacchari" = "pink",
             "Fusarium" = "red"),
           Race = c(
             "np" = "bisque",
             "Race 1" = "gold4",
             "Race 2" = "yellow3",
             "Race 3" = "lightblue",
             "Race 4" = "navy",
             "Tropical Race 4" = "green4"))

anno_colours_cec = colorRamp2(c(0, 150), c("white", "darkorchid4"))
anno_colours_ce = colorRamp2(c(0, 600), c("white", "darkolivegreen"))
anno_colours_mimp = colorRamp2(c(0, 800), c("white", "goldenrod1"))

# ---- create heatmap annotations ---- #

# add column barplot
column_anno = HeatmapAnnotation(
  "CEC size" = anno_barplot(colSums(binary_matrix), 
                            outline = FALSE, 
                            gp = gpar(fill = "black")))

#add row data - CEC, CE and mimp count.
row_anno_l <- rowAnnotation(
  "Total CECs" = heatmap_metadf_ordered$CECs, 
  "Total CEs" = heatmap_metadf_ordered$CEs,
  "Total mimps" = heatmap_metadf_ordered$mimps,
  col = list("Total CECs" = anno_colours_cec,
             "Total CEs" = anno_colours_ce,
             "Total mimps" = anno_colours_mimp),
  gp = gpar(col = "white")
)


row_anno_r = rowAnnotation(
  "Species" = heatmap_metadf_ordered$Species, 
  "Race" = heatmap_metadf_ordered$race, 
  col = anno_colours_r, 
  na_col = NA, 
  gp = gpar(col = "white"))
 
# ---- pheatmap plot of CECs ---- #

effector_heatmap <- ComplexHeatmap::pheatmap(
  binary_matrix, 
  color = colorRampPalette(c("grey90", "black"))(2), 
  name = "Binary distribution",
  legend = T,
  heatmap_legend_param = list(
    #at = seq(1, 10, by = 1),  #wär gleich: at = 1:10,       
    at = 0:1,
    legend_gp = gpar(fill = 0:1, fontsize = 2),
    color_bar = "discrete"
  ),
  legend_labels = c("Absent", "Present"),
  show_colnames = F,
  clustering_distance_rows = "binary",
  clustering_distance_cols = "binary",
  #cellwidth = 2, 
  #cellheight = 20,
  border_color = NA,
  treeheight_row = 80,
  treeheight_col = 20,
  na_col = "white", 
  row_labels = ID,
  row_names_side = "right",
  top_annotation = column_anno,
  left_annotation = row_anno_l,
  right_annotation = row_anno_r,
  fontsize = 12
)

# add bar plot annotations
effector_heatmap 

#save it
png(file="EffectorsHeatmap.png", width = 24, height = 12, unit = "in", res = 150)
draw(effector_heatmap)
dev.off()

```


As well as plotting the CEC distribution, I also want to get a numerical overview. First, I looked at the overall distribution and summary statistics of CECs.
```{r stats of effector clusters per fsp}

# ---- candidate effector clusters in Fo ---- #

# extract just the Fo rows from the CEC_metadata
Fo_CEC_medtadata <- subset(CEC_metadata, !grepl("Other", species_group))
#summarise
summary(Fo_CEC_medtadata)
```
The number of CECs in Fo. only doesn't vary as widely as the number of CECs across all Fusarium assemblies included (see range).

Next, I looked at specific fsp. of interest as well as comparing the *F. sacchari*  genome assemblies. 
```{r stats of effector clusters per fsp 2}

# ---- candidate effector clusters in fsp ---- #

# extract just the cubense rows from the CEC_metadata
Foc_CEC_medtadata <- subset(CEC_metadata, grepl("cubense", fsp))
summary(Foc_CEC_medtadata)

# extract just the lactucae rows from the CEC_metadata
Fola_CEC_medtadata <- subset(CEC_metadata, grepl("lactucae", fsp))
summary(Fola_CEC_medtadata)


# extract just the apii rows from the CEC_metadata
Foa_CEC_medtadata <- subset(CEC_metadata, grepl("apii", fsp))
summary(Foa_CEC_medtadata)


# extract just the coriandrii rows from the CEC_metadata
Foci_CEC_medtadata <- subset(CEC_metadata, grepl("coriandrii", fsp))
summary(Foci_CEC_medtadata)


# ---- candidate effector clusters in F. sacchari and SY-2 ---- #

# extract just the cubense rows from the CEC_metadata
Fs_CEC_medtadata <- subset(CEC_metadata, grepl("FS66|NRRL_66326|SY-2", isolate_code))
summary(Fs_CEC_medtadata)


```

#### Core CEC distribution

I also wanted to know what CECs were shared among all assemblies, and which were shared among all Fo. and which were shared among all assemblies in a specific fsp. 

```{r stats of core effector clusters}
# ---- summarise the distribution of candidate effector clusters in all assemblies  ---- #

# count the number of rows where the column total is >= the number of rows (a shared candidate effector cluster!)
shared_cluster <- heatmap_df %>%
  select_if(colSums(heatmap_df) >= nrow(heatmap_df))
# count the number of columns 
ncol(shared_cluster)

# ---- summarise the distribution of candidate effector clusters in Fo ---- #

# subset only the Fo rows
heatmap_Fo_only <- subset(heatmap_df, grepl("^Fo", rownames(heatmap_df)))
# count the number of rows where the column total is >= the number of Fo rows (a shared candidate effector cluster!)
heatmap_Fo_shared <- heatmap_Fo_only %>%
  select_if(colSums(heatmap_Fo_only) >= nrow(heatmap_Fo_only))
# count the number of columns 
ncol(heatmap_Fo_shared)

# ---- summarise the distribution of candidate effector clusters in cubense ---- #

# subset only the Foc rows
heatmap_Foc_only <- subset(heatmap_df, grepl("^Fo._fsp._cubense", rownames(heatmap_df)))
# count the number of rows where the column total is >= the number of Fo rows (a shared candidate effector cluster!)
heatmap_Foc_shared <- heatmap_Foc_only %>%
  select_if(colSums(heatmap_Foc_only) >= nrow(heatmap_Foc_only))
# count the number of columns 
ncol(heatmap_Foc_shared)

# ---- summarise the distribution of candidate effector clusters in lactucae ---- #

# subset only the Fola rows
heatmap_Fola_only <- subset(heatmap_df, grepl("^Fo._fsp._lactucae", rownames(heatmap_df)))
# count the number of rows where the column total is >= the number of Fo rows (a shared candidate effector cluster!)
heatmap_Fola_shared <- heatmap_Fola_only %>%
  select_if(colSums(heatmap_Fola_only) >= nrow(heatmap_Fola_only))
# count the number of columns 
ncol(heatmap_Fola_shared)

# ---- summarise the distribution of candidate effector clusters in apii ---- #

# subset only the Foa rows
heatmap_Foa_only <- subset(heatmap_df, grepl("^Fo._fsp._apii", rownames(heatmap_df)))
# count the number of rows where the column total is >= the number of Fo rows (a shared candidate effector cluster!)
heatmap_Foa_shared <- heatmap_Foa_only %>%
  select_if(colSums(heatmap_Foa_only) >= nrow(heatmap_Foa_only))
# count the number of columns 
ncol(heatmap_Foa_shared)

# ---- summarise the distribution of candidate effector clusters in coriandrii ---- #

# subset only the Foci rows
heatmap_Foci_only <- subset(heatmap_df, grepl("^Fo._fsp._coriandrii", rownames(heatmap_df)))
# count the number of rows where the column total is >= the number of Fo rows (a shared candidate effector cluster!)
heatmap_Foci_shared <- heatmap_Foci_only %>%
  select_if(colSums(heatmap_Foci_only) >= nrow(heatmap_Foci_only))
# count the number of columns 
ncol(heatmap_Foci_shared)

# ---- summarise the distribution of candidate effector clusters in apii and coridanrii (as they share some hosts) ---- #

# subset only the Foa and Foci rows
heatmap_Foa_c_only <- subset(heatmap_df, grepl("^Fo._fsp._apii|^Fo._fsp._coriandrii", rownames(heatmap_df)))
# count the number of rows where the column total is >= the number of Fo rows (a shared candidate effector cluster!)
heatmap_Foa_c_shared <- heatmap_Foa_c_only %>%
  select_if(colSums(heatmap_Foa_c_only) >= nrow(heatmap_Foa_c_only))
# count the number of columns 
ncol(heatmap_Foa_c_shared)


# ---- summarise the distribution of candidate effector clusters in F. sacchari and SY-2) ---- #

# subset only the Foa and Foci rows
heatmap_Fs_only <- subset(heatmap_df, grepl("^F._sacchari_|^F._TNAU", rownames(heatmap_df)))
# count the number of rows where the column total is >= the number of Fo rows (a shared candidate effector cluster!)
heatmap_Fs_shared <- heatmap_Fs_only %>%
  select_if(colSums(heatmap_Fs_only) >= nrow(heatmap_Fs_only))
# count the number of columns 
ncol(heatmap_Fs_shared)

```

Are the 'core CECs' in Fs also found in Focub? 

```{r banana pathogen core}
# ---- summarise the distribution of candidate effector clusters in F. sacchari and SY-2) ---- #

# subset only the Foa and Foci rows
heatmap_banana_only <- subset(heatmap_df, grepl("^Fo._fsp._cubense|^F._sacchari_|^F._TNAU", rownames(heatmap_df)))
# count the number of rows where the column total is >= the number of Fo rows (a shared candidate effector cluster!)
heatmap_banana_shared <- heatmap_banana_only %>%
  select_if(colSums(heatmap_banana_only) >= nrow(heatmap_banana_only))
# count the number of columns 
ncol(heatmap_banana_shared)

```

How are CECs distributed among races?

```{r race stats of CECs in fsp}
# ---- subset the fsp of interest ---- #
# cubense
foc_CEC_stats_sum <- Foc_CEC_medtadata %>%
  group_by(race) %>%
  summarize(count = n_distinct(isolate_code),
            mean_CEC = mean(no._CECs),
            min_CEC = min(no._CECs),
            max_CEC = max(no._CECs))
# lactucae
fola_CEC_stats_sum <- Fola_CEC_medtadata %>%
  group_by(race) %>%
  summarize(count = n_distinct(isolate_code),
            mean_CEC = mean(no._CECs),
            min_CEC = min(no._CECs),
            max_CEC= max(no._CECs))
# apii 
foa_CEC_stats_sum <- Foa_CEC_medtadata  %>%
  group_by(race) %>%
  summarize(count = n_distinct(isolate_code),
            mean_CEC = mean(no._CECs),
            min_CEC = min(no._CECs),
            max_CEC = max(no._CECs))

# print it nicely
knitr::kable(foc_CEC_stats_sum)
knitr::kable(fola_CEC_stats_sum)
knitr::kable(foa_CEC_stats_sum)

```


### Candidate effector cluster distribution in Fo. fsp. cubense

Now I have my overall heatmap, I want to look at some of the fsp in more detail, including the TEF phylogeny data - particularly those for which we have multiple races available. I subset my metadata, searched for all cases that did not match the regex "Fo._fsp._cubense" and dropped them from the tree using the `drop.tip` function. I the reconstructed my tree using just the Foc tef phylo and foc effector profiles using the gheatmap package from ggtree. 

```{r cubense effector distib, fig.height= 10, fig.width= 20}

# ---- subset foc metadata ---- #
#identify all rows in the metadata which do not contain cubense 
foc_set_df <- subset(metadata, !grepl("Fo._fsp._cubense|Fo._Fo47", label))
#subset just tip labels
foc_set <- data.frame("label" = foc_set_df[,c("label")])
# convert it to a list 
foc_set_2 <- paste(foc_set$label, sep = ",")

# ---- subset foc heatmap data ---- #
# reduce the white space in the heatmap but filtering columns where there is no data for foc
# first we extract only the foc rows using the same approach as for the metadata, but instead we perform on the binary matrix
foc_heat_df <- subset(binary_matrix, grepl("Fo._fsp._cubense|Fo._Fo47", rownames(binary_matrix)))
# now we need to drop the empty columns 
foc_heat_df <- foc_heat_df[, colSums(foc_heat_df != 0) > 0]

# ---- Cluster the heatmap data (again)---- #
# normalisiation is mandatory for clustering, but as my data is binary - i did not normalise. 
# Compute hierarchical clustering of columns
foc_heat_df <- cluster_matrix(foc_heat_df, dim = 'col', method ="ward.D2")

# ---- build the basic foc tree ---- #
#dop the non foc tip from the tree
tree_reduced <- drop.tip(tree, foc_set_2)
#build a tree from this data and add in out metadata
foc_tree <- ggtree(tree_reduced, ladderize = T ) %<+% metadata 

# ---- build full foc specific tree ---- #
# now make the tree pretty 
foc_tree_2 <- foc_tree +  
  #geom_tiplab(aes(label = full_name), offset = 0.00001) +
  geom_tiplab(aes(label = isolate_code), color = "grey20", offset = 0.0003, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = race), offset = 0.0038, linetype = "blank", geom = "text", align = TRUE)+
  geom_tippoint(aes(shape = source), size = 3) +
  geom_rootedge() +
  theme(legend.position = "bottom")

#add extra scale so we can plot fsp with colour
foc_tree_3 <- foc_tree_2 + new_scale_fill()
# add race data
foc_tree_4 <- gheatmap(foc_tree_3, foc_heat_df, offset=0.008, colnames=T, colnames_angle=90, hjust=1, font.size=3, legend_title="Presence/\nAbsence", color = "grey",  width = 4)  +
  scale_fill_continuous(name = "Presence/\nAbsence",
                        low = "grey90", high = "black",
                        breaks = c("Absent","Present"),
                        na.value = "grey")+
  guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "horizontal", legend.margin = margin())+
   geom_treescale(x=0, y=0.1, width = 0.004) +
  guides(shape = guide_legend(override.aes = list(size = 2))) +
    theme(axis.text.x = element_text(angle = 90,         #Adjust the text orientation on the x axis
                                   vjust = 0.5, 
                                   hjust=1,
                                   size = 8,
                                   colour = "white" )) +
  coord_cartesian(clip = "off")

# plot the tree
plot(foc_tree_4)

# save the tree
ggsave("HeatmapAndPhylo_CubenseOnly.png", width = 20, height = 10)

```

We can see that the effector profiles differ based on race and overall tef1 phylogeny. Interestingly there is one candidate which is shared across the R1 and suspected STR4 isolates but not found in the TR4 isolates - cognate R gene? 

I think it is interesting, though we cannot do any really significant stats on this, to look at candidate effector and mimp content among the race groups. 

I was expecting to see a fairly similar number of mimps and candidate effectors among the TR4 isolates, as they are from a monophyletic clade in tef and rbp2 phylos, but number of candidates varies. I am thinking it may be due to assembly quality too? Looking at the Foa isolates is a good way to do this, as the R4 and R2 assemblies are from the same isolates but diff versions prepared by diff people using different methods. 

### Candidate effector cluster distribution in Fo. fsp. lactucae and Fo. fsp. apii

```{r coriandrii and apii effector distib, fig.height= 10, fig.width= 20}

# ---- subset metadata ---- #
#identify all rows in the metadata which do not contain apii and coriandrii 
foa_c_set_df <- subset(metadata, !grepl("Fo._fsp._coriandrii|Fo._fsp._apii|Fo._Fo47", label))
#subset just tip labels
foa_c_set <- data.frame("label" = foa_c_set_df[,c("label")])
# convert it to a list 
foa_c_set_2 <- paste(foa_c_set$label, sep = ",")

# ---- subset heatmap data ---- #
# reduce the white space in the heatmap but filtering columns where there is no data for foc
# first we extract only the foc rows using the same approach as for the metadata, but instead we perform on the binary matrix
foa_c_heat_df <- subset(binary_matrix, grepl("Fo._fsp._coriandrii|Fo._fsp._apii|Fo._Fo47", rownames(binary_matrix)))
# now we need to drop the empty columns 
foa_c_heat_df <- foa_c_heat_df[, colSums(foa_c_heat_df != 0) > 0]

# ---- Cluster the heatmap data (again)---- #
# normalisiation is mandatory for clustering, but as my data is binary - i did not normalise. 
# Compute hierarchical clustering of columns
foa_c_heat_df <- cluster_matrix(foa_c_heat_df, dim = 'col', method ="ward.D2")

# ---- build the basic foc tree ---- #
#dop the non foc tip from the tree
tree_reduced <- drop.tip(tree, foa_c_set_2)
#build a tree from this data and add in out metadata
foa_c_tree <- ggtree(tree_reduced, ladderize = T ) %<+% metadata 

# ---- build full foc specific tree ---- #
# now make the tree pretty 
foa_c_tree_2 <- foa_c_tree +  
  #geom_tiplab(aes(label = full_name), offset = 0.00001) +
  geom_tiplab(aes(label = fsp), color = "grey20", offset = 0.0003, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = isolate_code), color = "grey20", offset = 0.002, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = race), offset = 0.0042, linetype = "blank", geom = "text", align = TRUE)+
  geom_tippoint(aes(shape = source), size = 3) +
  geom_rootedge() +
  theme(legend.position = "bottom")

#add extra scale so we can plot fsp with colour
foa_c_tree_3 <- foa_c_tree_2 + new_scale_fill()
# add race data
foa_c_tree_4 <- gheatmap(foa_c_tree_3, foa_c_heat_df, offset=0.0065, colnames=T, colnames_angle=90, hjust=1, font.size=3, legend_title="Presence/\nAbsence", color = "grey",  width = 4)  +
  scale_fill_continuous(name = "Presence/\nAbsence",
                        low = "grey90", high = "black",
                        breaks = c("Absent","Present"),
                        na.value = "white")+
  guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "horizontal", legend.margin = margin())+
   geom_treescale(x=0, y=.1, width = 0.004) +
  guides(shape = guide_legend(override.aes = list(size = 2))) +
    theme(axis.text.x = element_text(angle = 90,         #Adjust the text orientation on the x axis
                                   vjust = 0.5, 
                                   hjust=1,
                                   size = 8,
                                   colour = "white" )) +
  coord_cartesian(clip = "off") 
# plot the tree
plot(foa_c_tree_4)

# save the tree
ggsave("HeatmapAndPhylo_ApiiAndCoriandriiOnly.png", width = 20, height = 10)

```


As I compared effector content between races for Foc, I also want to do the same thing for Fola. Again, I would have liked to performed some statistical analysis, but pretty much all blogs, posts, and papers I have come across have recommended not doing it with a such a small sample size. I have therefore just plotted the effector data for the Fola isolates. I also included matthiolae, as it appears to be in the same clade based on TEF, but displays a different candidate effector profiles.

```{r lactucae effector distib, fig.height= 10, fig.width= 20}

# ---- subset fola metadata ---- #
#identify all rows in the metadata which do not contain lactucae 
fola_set_df <- subset(metadata, !grepl("Fo._fsp._lactucae|Fo._fsp._matthiolae|Fo._Fo47", label))
#subset just tip labels
fola_set <- data.frame("label" = fola_set_df[,c("label")])
# convert it to a list 
fola_set_2 <- paste(fola_set$label, sep = ",")

# ---- subset fola heatmap data ---- #
# reduce the white space in the heatmap but filtering columns where there is no data for foc
# first we extract only the foc rows using the same approach as for the metadata, but instead we perform on the binary matrix
fola_heat_df <- subset(binary_matrix, grepl("Fo._fsp._lactucae|Fo._fsp._matthiolae|Fo._Fo47", rownames(binary_matrix)))
# now we need to drop the empty columns 
fola_heat_df <- fola_heat_df[, colSums(fola_heat_df != 0) > 0]

# ---- Cluster the heatmap data (again)---- #
# normalisiation is mandatory for clustering, but as my data is binary - i did not normalise. 
# Compute hierarchical clustering of columns
fola_heat_df <- cluster_matrix(fola_heat_df, method ="ward.D2")

# ---- build the basic foc tree ---- #
#dop the non foc tip from the tree
tree_reduced <- drop.tip(tree, fola_set_2)
#build a tree from this data and add in out metadata
fola_tree <- ggtree(tree_reduced, ladderize = T ) %<+% metadata 

# ---- build full foc specific tree ---- #
# now make the tree pretty 
fola_tree_2 <- fola_tree +  
  geom_tiplab(aes(label = fsp), offset = 0.0003) +
  geom_tiplab(aes(label = isolate_code), color = "grey20", offset = 0.002, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = race), offset = 0.0042, linetype = "blank", geom = "text", align = TRUE)+
  geom_tippoint(aes(shape = source), size = 3) +
  geom_rootedge() +
  theme(legend.position = "bottom")

#add extra scale so we can plot fsp with colour
fola_tree_3 <- fola_tree_2 + new_scale_fill()

# add race data
fola_tree_4 <- gheatmap(fola_tree_3, fola_heat_df, offset=0.0065, colnames=T, colnames_angle=90, hjust=1, font.size=3, legend_title="Presence/\nAbsence", color = "grey",  width = 4)  +
  scale_fill_continuous(name = "Presence/\nAbsence",
                        low = "grey90", high = "black",
                        breaks = c("Absent","Present"),
                        na.value = "white") +
  guides(fill = guide_colourbar(barwidth = 5, barheight = 1)) +
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "horizontal", legend.margin = margin())  +
   geom_treescale(x=0, y=.1, width = 0.004) +
  guides(shape = guide_legend(override.aes = list(size = 2))) +
    theme(axis.text.x = element_text(angle = 90,         #Adjust the text orientation on the x axis
                                   vjust = 0.5, 
                                   hjust=1,
                                   size = 8,
                                   colour = "white" )) +
  coord_cartesian(clip = "off") 

# plot the tree
plot(fola_tree_4)

# save the tree
ggsave("HeatmapAndPhylo_LactucaeOnly.png", width = 20, height = 10)

```


### Misc

```{r}
# ---- load session data --- #
session_data <- sessionInfo()
session_data
```

